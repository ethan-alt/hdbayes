% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glm_logml_npp.R
\name{glm.logml.npp}
\alias{glm.logml.npp}
\title{Log marginal likelihood of a GLM under normalized power prior (NPP)}
\usage{
glm.logml.npp(
  post.samples,
  formula,
  family,
  data.list,
  a0.lognc,
  lognc,
  offset.list = NULL,
  beta.mean = NULL,
  beta.sd = NULL,
  disp.mean = NULL,
  disp.sd = NULL,
  a0.shape1 = 1,
  a0.shape2 = 1,
  a0.lower = NULL,
  a0.upper = NULL,
  bridge.args = NULL
)
}
\arguments{
\item{post.samples}{an object of class \code{draws_df}, \code{draws_matrix}, \code{matrix}, or \code{data.frame} giving posterior
samples of a GLM under NPP, such as the output from \code{\link[=glm.npp]{glm.npp()}}. Each row corresponds to
the posterior samples obtained from one iteration of MCMC. The column names of \code{post.samples}
should include the names of covariates for regression coefficients, such as "(Intercept)", and
"dispersion" for the dispersion parameter, if applicable.}

\item{formula}{a two-sided formula giving the relationship between the response variable and covariates.}

\item{family}{an object of class \code{family}. See \code{\link[stats:family]{?stats::family}}.}

\item{data.list}{a list of \code{data.frame}s. The first element in the list is the current data, and the rest
are the historical data sets.}

\item{a0.lognc}{a vector giving values of the power prior parameter for which the logarithm of the normalizing
constant has been evaluated.}

\item{lognc}{an S by T matrix where S is the length of a0.lognc, T is the number of historical data sets, and
the j-th column, j = 1, ..., T, is a vector giving the logarithm of the normalizing constant (as
estimated by \code{\link[=glm.npp.lognc]{glm.npp.lognc()}} for a0.lognc using the j-th historical data set.}

\item{offset.list}{a list of vectors giving the offsets for each data. The length of offset.list is equal to
the length of data.list. The length of each element of offset.list is equal to the number
of rows in the corresponding element of data.list. Defaults to a list of vectors of 0s.}

\item{beta.mean}{a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the mean parameters for the initial prior on regression coefficients. If a scalar is provided,
beta.mean will be a vector of repeated elements of the given scalar. Defaults to a vector of 0s.}

\item{beta.sd}{a scalar or a vector whose dimension is equal to the number of regression coefficients giving
the sd parameters for the initial prior on regression coefficients. If a scalar is provided,
same as for beta.mean. Defaults to a vector of 10s.}

\item{disp.mean}{mean parameter for the half-normal prior on dispersion parameter. Defaults to 0.}

\item{disp.sd}{sd parameter for the half-normal prior on dispersion parameter. Defaults to 10.}

\item{a0.shape1}{first shape parameter for the i.i.d. beta prior on a0 vector. When \code{a0.shape1 == 1} and
\code{a0.shape2 == 1}, a uniform prior is used.}

\item{a0.shape2}{second shape parameter for the i.i.d. beta prior on a0 vector. When \code{a0.shape1 == 1} and
\code{a0.shape2 == 1}, a uniform prior is used.}

\item{a0.lower}{a scalar or a vector whose dimension is equal to the number of historical data sets giving the
lower bounds for each element of the a0 vector. If a scalar is provided, a0.lower will be a
vector of repeated elements of the given scalar. Defaults to a vector of 0s.}

\item{a0.upper}{a scalar or a vector whose dimension is equal to the number of historical data sets giving the
upper bounds for each element of the a0 vector. If a scalar is provided, same as for a0.lower.
Defaults to a vector of 1s.}

\item{bridge.args}{a \code{list} giving arguments (other than samples, log_posterior, data, lb, ub) to pass onto
\code{\link[bridgesampling:bridge_sampler]{bridgesampling::bridge_sampler()}}.}
}
\value{
The function returns a \code{list} with the following objects

\describe{
\item{model}{"NPP"}

\item{logml}{the estimated logarithm of the marginal likelihood}

\item{bs}{an object of class \code{bridge} or \code{bridge_list} giving the output from \code{\link[bridgesampling:bridge_sampler]{bridgesampling::bridge_sampler()}}}
}
}
\description{
Uses Markov chain Monte Carlo (MCMC) and bridge sampling to estimate the logarithm of the marginal
likelihood of a GLM under NPP.
}
\details{
This function mirrors the arguments of \code{\link[=glm.npp]{glm.npp()}} (except for those relevant for MCMC sampling),
and introduces two additional arguments: \code{post.samples} and \code{bridge.args}. \code{post.samples} provides
posterior samples from the GLM under NPP (e.g., the output from \code{\link[=glm.npp]{glm.npp()}}), while \code{bridge.args}
specifies arguments to pass onto \code{\link[bridgesampling:bridge_sampler]{bridgesampling::bridge_sampler()}} (other than \code{samples},
\code{log_posterior}, \code{data}, \code{lb}, \code{ub}).

It is crucial to ensure that the values assigned to the shared arguments in this function and
\code{\link[=glm.npp]{glm.npp()}} correspond to those used in generating \code{post.samples}.
}
\examples{
\donttest{
  if(requireNamespace("parallel")){
    data(actg019)
    data(actg036)
    ## take subset for speed purposes
    actg019 = actg019[1:100, ]
    actg036 = actg036[1:50, ]

    library(parallel)
    ncores    = 2
    data.list = list(data = actg019, histdata = actg036)
    formula   = cd4 ~ treatment + age + race
    family    = poisson()
    a0        = seq(0, 1, length.out = 11)
    if (instantiate::stan_cmdstan_exists()) {
      ## call created function
      ## wrapper to obtain log normalizing constant in parallel package
      logncfun = function(a0, ...){
        hdbayes::glm.npp.lognc(
          formula = formula, family = family, a0 = a0, histdata = data.list[[2]],
          ...
        )
      }

      cl = makeCluster(ncores)
      clusterSetRNGStream(cl, 123)
      clusterExport(cl, varlist = c('formula', 'family', 'data.list'))
      a0.lognc = parLapply(
        cl = cl, X = a0, fun = logncfun, iter_warmup = 500,
        iter_sampling = 1000, chains = 1, refresh = 0
      )
      stopCluster(cl)
      a0.lognc = data.frame( do.call(rbind, a0.lognc) )

      ## sample from normalized power prior
      d.npp = glm.npp(
        formula = formula,
        family = family,
        data.list = data.list,
        a0.lognc = a0.lognc$a0,
        lognc = matrix(a0.lognc$lognc, ncol = 1),
        chains = 1, iter_warmup = 500, iter_sampling = 1000,
        refresh = 0
      )
      glm.logml.npp(
        post.samples = d.npp,
        formula = formula, family = family,
        data.list = data.list,
        a0.lognc = a0.lognc$a0,
        lognc = matrix(a0.lognc$lognc, ncol = 1),
        bridge.args = list(silent = TRUE)
      )
    }
  }
}
}
\references{
Duan, Y., Ye, K., and Smith, E. P. (2005). Evaluating water quality using power priors to incorporate historical information. Environmetrics, 17(1), 95â€“106.

Gronau, Q. F., Singmann, H., and Wagenmakers, E.-J. (2020). bridgesampling: An r package for estimating normalizing constants. Journal of Statistical Software, 92(10).
}
