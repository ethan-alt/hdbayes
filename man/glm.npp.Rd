% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/glm_npp.R
\name{glm.npp}
\alias{glm.npp}
\title{Posterior of normalized power prior}
\usage{
glm.npp(
  formula,
  family,
  data,
  histdata,
  a0,
  lognc,
  beta.mean = NULL,
  beta.cov = NULL,
  disp.shape = 2.1,
  disp.scale = 1.1,
  a0.shape1 = 1,
  a0.shape2 = 1,
  offset = NULL,
  offset0 = NULL,
  ...
)
}
\arguments{
\item{formula}{a two-sided formula giving the relationship between the response variable and covariates}

\item{family}{an object of class \code{family}. See \code{\link[stats:family]{?stats::family}}}

\item{data}{a \code{data.frame} giving the current data}

\item{histdata}{a \code{data.frame} giving the historical data}

\item{a0}{vector giving values of the power prior parameter for which the logarithm of the normalizing constant has been evaluated}

\item{lognc}{vector (of same length as a0) giving the logarithm of the normalizing constant (as estimated by \code{\link[hdbayes]{glm.npp.lognc}})}

\item{beta.mean}{mean parameter for initial prior on regression coefficients (including intercept). Defaults to a vector of zeros.}

\item{beta.cov}{covariance parameter for initial prior on regression coefficients (including intercept). Defaults to a diagonal covariance matrix where each variance is equal to 100.}

\item{disp.shape}{shape parameter for inverse-gamma prior on dispersion parameter}

\item{disp.scale}{scale parameter for inverse-gamma prior on dispersion parameter}

\item{a0.shape1}{first shape parameter for beta prior on a0. When \code{a0.shape1 == 1} and \code{a0.shape2 == 1}, a uniform prior is used.}

\item{a0.shape2}{first shape parameter for beta prior on a0. When \code{a0.shape1 == 1} and \code{a0.shape2 == 1}, a uniform prior is used.}

\item{offset}{vector whose dimension is equal to the rows of the current data set giving an offset for the current data. Defaults to a vector of 0s}

\item{offset0}{vector whose dimension is equal to the rows of the historical data set giving an offset for the historical data. Defaults to a vector of 0s}

\item{...}{arguments passed to \code{\link[rstan:stanmodel-method-sampling]{rstan::sampling()}} (e.g. iter, chains).}
}
\value{
\preformatted{       an object of class `stanfit` giving posterior samples
}
}
\description{
Sample from the posterior distribution of a GLM using the normalized power prior
(NPP). Before using this function, users must estimate the logarithm of the
normalizing constant across a range of power prior parameters (a0), possibly
smoothing techniques over a find grid.
}
\examples{
\dontrun{
  library(parallel)
  ncores = parallel::detectCores()

  warmup = 1000


  ## function to parallelize estimation of log normalizing constant
  logncfun = function(a0, ...)
    hdbayes::glm.npp.lognc(
      formula = cd4 ~ treatment + age + race, family = poisson(),
      histdata = actg036, a0 = a0, ...
    )

  ## set up parallelization
  cl = makeCluster(ncores)
  clusterSetRNGStream(cl, 123)

  ## estimate normalizing constant in parallel
  a0.lognc = parLapply(
    cl = cl, X = seq(0, 1, 4*ncores), fun = logncfun, iter = 5000, warmup = warmup, refresh = 0
  )
  stopCluster(cl)
  a0.lognc = data.frame( do.call(rbind, a0.lognc) )

  ## sample from normalized power prior
  glm.npp(
    formula = cd4 ~ treatment + age + race,
    family = poisson(),
    data = actg019,
    histdata = actg036,
    a0 = a0.lognc$a0,
    lognc = a0.lognc$lognc,
    cores = ncores, chains = ncores, iter = samples,
    warmup = warmup, refresh = 0
  )
}

}
